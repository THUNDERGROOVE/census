// DO NOT EDIT!
// Code generated by ffjson <https://github.com/pquerna/ffjson>
// source: /home/nick/code/src/github.com/THUNDERGROOVE/census/character.go
// DO NOT EDIT!

package census

import (
	"bytes"
	"encoding/json"
	"fmt"
	fflib "github.com/pquerna/ffjson/fflib/v1"
)

func (mj *Character) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if mj == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *Character) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if mj == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{"character_id":`)
	fflib.WriteJsonString(buf, string(mj.ID))
	/* Inline struct. type=struct { First string "json:\"first\""; Lower string "json:\"first_lower\"" } kind=struct */
	buf.WriteString(`,"name":{ "first":`)
	fflib.WriteJsonString(buf, string(mj.Name.First))
	buf.WriteString(`,"first_lower":`)
	fflib.WriteJsonString(buf, string(mj.Name.Lower))
	buf.WriteByte('}')
	buf.WriteString(`,"faction_id":`)
	fflib.WriteJsonString(buf, string(mj.FactionID))
	buf.WriteString(`,"title_id":`)
	fflib.WriteJsonString(buf, string(mj.TitleID))
	/* Inline struct. type=struct { Creation string "json:\"creation\""; LastSave string "json:\"last_save\""; LastLogin string "json:\"last_login\""; LoginCount string "json:\"login_count\""; MinutesPlayed string "json:\"minutes_played\"" } kind=struct */
	buf.WriteString(`,"times":{ "creation":`)
	fflib.WriteJsonString(buf, string(mj.Times.Creation))
	buf.WriteString(`,"last_save":`)
	fflib.WriteJsonString(buf, string(mj.Times.LastSave))
	buf.WriteString(`,"last_login":`)
	fflib.WriteJsonString(buf, string(mj.Times.LastLogin))
	buf.WriteString(`,"login_count":`)
	fflib.WriteJsonString(buf, string(mj.Times.LoginCount))
	buf.WriteString(`,"minutes_played":`)
	fflib.WriteJsonString(buf, string(mj.Times.MinutesPlayed))
	buf.WriteByte('}')
	/* Inline struct. type=struct { Earned string "json:\"earned_points\""; Gifted string "json:\"gifted_points\""; Spent string "json:\"spent_points\""; Available string "json:\"available_points\""; PercentToNext string "json:\"percent_to_next\"" } kind=struct */
	buf.WriteString(`,"certs":{ "earned_points":`)
	fflib.WriteJsonString(buf, string(mj.Certs.Earned))
	buf.WriteString(`,"gifted_points":`)
	fflib.WriteJsonString(buf, string(mj.Certs.Gifted))
	buf.WriteString(`,"spent_points":`)
	fflib.WriteJsonString(buf, string(mj.Certs.Spent))
	buf.WriteString(`,"available_points":`)
	fflib.WriteJsonString(buf, string(mj.Certs.Available))
	buf.WriteString(`,"percent_to_next":`)
	fflib.WriteJsonString(buf, string(mj.Certs.PercentToNext))
	buf.WriteByte('}')
	/* Inline struct. type=struct { Rank string "json:\"value\""; PercentToNext string "json:\"percent_to_next\"" } kind=struct */
	buf.WriteString(`,"battle_rank":{ "value":`)
	fflib.WriteJsonString(buf, string(mj.Battlerank.Rank))
	buf.WriteString(`,"percent_to_next":`)
	fflib.WriteJsonString(buf, string(mj.Battlerank.PercentToNext))
	buf.WriteByte('}')
	/* Inline struct. type=struct { Count string "json:\"count\""; Time string "json:\"time\"" } kind=struct */
	buf.WriteString(`,"daily_ribbon":{ "count":`)
	fflib.WriteJsonString(buf, string(mj.DailyRibbon.Count))
	buf.WriteString(`,"time":`)
	fflib.WriteJsonString(buf, string(mj.DailyRibbon.Time))
	buf.WriteByte('}')
	buf.WriteString(`,"profile_id":`)
	fflib.WriteJsonString(buf, string(mj.ProfileID))
	/* Inline struct. type=struct { ID string "json:\"outfit_id\""; Name string "json:\"name\""; Alias string "json:\"alias\""; LeaderID string "json:\"leader_character_id\""; MemberCount string "json:\"member_count\""; TimeCreated string "json:\"time_created\"" } kind=struct */
	buf.WriteString(`,"outfit":{ "outfit_id":`)
	fflib.WriteJsonString(buf, string(mj.Outfit.ID))
	buf.WriteString(`,"name":`)
	fflib.WriteJsonString(buf, string(mj.Outfit.Name))
	buf.WriteString(`,"alias":`)
	fflib.WriteJsonString(buf, string(mj.Outfit.Alias))
	buf.WriteString(`,"leader_character_id":`)
	fflib.WriteJsonString(buf, string(mj.Outfit.LeaderID))
	buf.WriteString(`,"member_count":`)
	fflib.WriteJsonString(buf, string(mj.Outfit.MemberCount))
	buf.WriteString(`,"time_created":`)
	fflib.WriteJsonString(buf, string(mj.Outfit.TimeCreated))
	buf.WriteByte('}')
	buf.WriteString(`,"online_status":`)
	fflib.WriteJsonString(buf, string(mj.OnlineStatus))
	/* Inline struct. type=struct { Stat []struct { Name string "json:\"stat_name\""; ProfileID string "json:\"profile_id\""; ValueForever string "json:\"value_forever\""; ValueMonthly string "json:\"value_monthly\""; ValueWeekly string "json:\"value_weekly\""; ValueDaily string "json:\"value_daily\""; ValueOneLifeMax string "json:\"value_one_life_max\""; LastSave string "json:\"last_save\"" } "json:\"stat\""; StatHistory []struct { Name string "json:\"stat_name\""; AllTime string "json:\"all_time\""; OneLifeMax string "json:\"one_life_max\""; Day map[string]string "json:\"day\""; Month map[string]string "json:\"Month\""; Week map[string]string "json:\"Week\"" } "json:\"stat_history\""; WeaponStat []struct { Name string "json:\"weapon_deaths\""; ItemID string "json:\"item_id\""; VehicleID string "json:\"vehicle_id\""; Value string "json:\"value\""; LastSave string "json:\"last_save\"" } "json:\"weapon_stat\"" } kind=struct */
	buf.WriteString(`,"stats":{ "stat":`)
	if mj.Stats.Stat != nil {
		buf.WriteString(`[`)
		for i, v := range mj.Stats.Stat {
			if i != 0 {
				buf.WriteString(`,`)
			}
			/* Inline struct. type=struct { Name string "json:\"stat_name\""; ProfileID string "json:\"profile_id\""; ValueForever string "json:\"value_forever\""; ValueMonthly string "json:\"value_monthly\""; ValueWeekly string "json:\"value_weekly\""; ValueDaily string "json:\"value_daily\""; ValueOneLifeMax string "json:\"value_one_life_max\""; LastSave string "json:\"last_save\"" } kind=struct */
			buf.WriteString(`{ "stat_name":`)
			fflib.WriteJsonString(buf, string(v.Name))
			buf.WriteString(`,"profile_id":`)
			fflib.WriteJsonString(buf, string(v.ProfileID))
			buf.WriteString(`,"value_forever":`)
			fflib.WriteJsonString(buf, string(v.ValueForever))
			buf.WriteString(`,"value_monthly":`)
			fflib.WriteJsonString(buf, string(v.ValueMonthly))
			buf.WriteString(`,"value_weekly":`)
			fflib.WriteJsonString(buf, string(v.ValueWeekly))
			buf.WriteString(`,"value_daily":`)
			fflib.WriteJsonString(buf, string(v.ValueDaily))
			buf.WriteString(`,"value_one_life_max":`)
			fflib.WriteJsonString(buf, string(v.ValueOneLifeMax))
			buf.WriteString(`,"last_save":`)
			fflib.WriteJsonString(buf, string(v.LastSave))
			buf.WriteByte('}')
		}
		buf.WriteString(`]`)
	} else {
		buf.WriteString(`null`)
	}
	buf.WriteString(`,"stat_history":`)
	if mj.Stats.StatHistory != nil {
		buf.WriteString(`[`)
		for i, v := range mj.Stats.StatHistory {
			if i != 0 {
				buf.WriteString(`,`)
			}
			/* Inline struct. type=struct { Name string "json:\"stat_name\""; AllTime string "json:\"all_time\""; OneLifeMax string "json:\"one_life_max\""; Day map[string]string "json:\"day\""; Month map[string]string "json:\"Month\""; Week map[string]string "json:\"Week\"" } kind=struct */
			buf.WriteString(`{ "stat_name":`)
			fflib.WriteJsonString(buf, string(v.Name))
			buf.WriteString(`,"all_time":`)
			fflib.WriteJsonString(buf, string(v.AllTime))
			buf.WriteString(`,"one_life_max":`)
			fflib.WriteJsonString(buf, string(v.OneLifeMax))
			if v.Day == nil {
				buf.WriteString(`,"day":null`)
			} else {
				buf.WriteString(`,"day":{ `)
				for key, value := range v.Day {
					fflib.WriteJsonString(buf, key)
					buf.WriteString(`:`)
					fflib.WriteJsonString(buf, string(value))
					buf.WriteByte(',')
				}
				buf.Rewind(1)
				buf.WriteByte('}')
			}
			if v.Month == nil {
				buf.WriteString(`,"Month":null`)
			} else {
				buf.WriteString(`,"Month":{ `)
				for key, value := range v.Month {
					fflib.WriteJsonString(buf, key)
					buf.WriteString(`:`)
					fflib.WriteJsonString(buf, string(value))
					buf.WriteByte(',')
				}
				buf.Rewind(1)
				buf.WriteByte('}')
			}
			if v.Week == nil {
				buf.WriteString(`,"Week":null`)
			} else {
				buf.WriteString(`,"Week":{ `)
				for key, value := range v.Week {
					fflib.WriteJsonString(buf, key)
					buf.WriteString(`:`)
					fflib.WriteJsonString(buf, string(value))
					buf.WriteByte(',')
				}
				buf.Rewind(1)
				buf.WriteByte('}')
			}
			buf.WriteByte('}')
		}
		buf.WriteString(`]`)
	} else {
		buf.WriteString(`null`)
	}
	buf.WriteString(`,"weapon_stat":`)
	if mj.Stats.WeaponStat != nil {
		buf.WriteString(`[`)
		for i, v := range mj.Stats.WeaponStat {
			if i != 0 {
				buf.WriteString(`,`)
			}
			/* Inline struct. type=struct { Name string "json:\"weapon_deaths\""; ItemID string "json:\"item_id\""; VehicleID string "json:\"vehicle_id\""; Value string "json:\"value\""; LastSave string "json:\"last_save\"" } kind=struct */
			buf.WriteString(`{ "weapon_deaths":`)
			fflib.WriteJsonString(buf, string(v.Name))
			buf.WriteString(`,"item_id":`)
			fflib.WriteJsonString(buf, string(v.ItemID))
			buf.WriteString(`,"vehicle_id":`)
			fflib.WriteJsonString(buf, string(v.VehicleID))
			buf.WriteString(`,"value":`)
			fflib.WriteJsonString(buf, string(v.Value))
			buf.WriteString(`,"last_save":`)
			fflib.WriteJsonString(buf, string(v.LastSave))
			buf.WriteByte('}')
		}
		buf.WriteString(`]`)
	} else {
		buf.WriteString(`null`)
	}
	buf.WriteByte('}')
	/* Inline struct. type=struct { Name struct { En string "json:\"en\""; De string "json:\"de\""; Es string "json:\"es\""; Fr string "json:\"fr\""; It string "json:\"it\""; Tr string "json:\"tr\"" } "json:\"name\""; ImageSetID string "json:\"image_set_id\""; ImageID string "json:\"image_id\""; ImagePath string "json:\"image_path\""; CodeTag string "json:\"code_tag\""; UserSelectable string "json:\"user_selectable\"" } kind=struct */
	/* Inline struct. type=struct { En string "json:\"en\""; De string "json:\"de\""; Es string "json:\"es\""; Fr string "json:\"fr\""; It string "json:\"it\""; Tr string "json:\"tr\"" } kind=struct */
	buf.WriteString(`,"faction":{ "name":{ "en":`)
	fflib.WriteJsonString(buf, string(mj.Faction.Name.En))
	buf.WriteString(`,"de":`)
	fflib.WriteJsonString(buf, string(mj.Faction.Name.De))
	buf.WriteString(`,"es":`)
	fflib.WriteJsonString(buf, string(mj.Faction.Name.Es))
	buf.WriteString(`,"fr":`)
	fflib.WriteJsonString(buf, string(mj.Faction.Name.Fr))
	buf.WriteString(`,"it":`)
	fflib.WriteJsonString(buf, string(mj.Faction.Name.It))
	buf.WriteString(`,"tr":`)
	fflib.WriteJsonString(buf, string(mj.Faction.Name.Tr))
	buf.WriteByte('}')
	buf.WriteString(`,"image_set_id":`)
	fflib.WriteJsonString(buf, string(mj.Faction.ImageSetID))
	buf.WriteString(`,"image_id":`)
	fflib.WriteJsonString(buf, string(mj.Faction.ImageID))
	buf.WriteString(`,"image_path":`)
	fflib.WriteJsonString(buf, string(mj.Faction.ImagePath))
	buf.WriteString(`,"code_tag":`)
	fflib.WriteJsonString(buf, string(mj.Faction.CodeTag))
	buf.WriteString(`,"user_selectable":`)
	fflib.WriteJsonString(buf, string(mj.Faction.UserSelectable))
	buf.WriteByte('}')
	buf.WriteString(`,"items":`)
	if mj.Items != nil {
		buf.WriteString(`[`)
		for i, v := range mj.Items {
			if i != 0 {
				buf.WriteString(`,`)
			}
			/* Inline struct. type=struct { ID string "json:\"item_id\""; StackCount string "json:\"stack_count\"" } kind=struct */
			buf.WriteString(`{ "item_id":`)
			fflib.WriteJsonString(buf, string(v.ID))
			buf.WriteString(`,"stack_count":`)
			fflib.WriteJsonString(buf, string(v.StackCount))
			buf.WriteByte('}')
		}
		buf.WriteString(`]`)
	} else {
		buf.WriteString(`null`)
	}
	buf.WriteString(`,"friends_list":`)
	if mj.FriendsList != nil {
		buf.WriteString(`[`)
		for i, v := range mj.FriendsList {
			if i != 0 {
				buf.WriteString(`,`)
			}
			/* Inline struct. type=struct { ID string "json:\"character_id\""; LastLoginTime string "json:\"last_login_time\""; Onlint string "json:\"online\"" } kind=struct */
			buf.WriteString(`{ "character_id":`)
			fflib.WriteJsonString(buf, string(v.ID))
			buf.WriteString(`,"last_login_time":`)
			fflib.WriteJsonString(buf, string(v.LastLoginTime))
			buf.WriteString(`,"online":`)
			fflib.WriteJsonString(buf, string(v.Onlint))
			buf.WriteByte('}')
		}
		buf.WriteString(`]`)
	} else {
		buf.WriteString(`null`)
	}
	buf.WriteString(`,"world_id":`)
	fflib.WriteJsonString(buf, string(mj.World))
	buf.WriteString(`,"error":`)
	fflib.WriteJsonString(buf, string(mj.Error))
	buf.WriteString(`,"expires":`)

	{

		obj, err = mj.Expires.MarshalJSON()
		if err != nil {
			return err
		}
		buf.Write(obj)

	}
	buf.WriteString(`,"last-updated":`)

	{

		obj, err = mj.LastUpdated.MarshalJSON()
		if err != nil {
			return err
		}
		buf.Write(obj)

	}
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_Characterbase = iota
	ffj_t_Characterno_such_key

	ffj_t_Character_ID

	ffj_t_Character_Name

	ffj_t_Character_FactionID

	ffj_t_Character_TitleID

	ffj_t_Character_Times

	ffj_t_Character_Certs

	ffj_t_Character_Battlerank

	ffj_t_Character_DailyRibbon

	ffj_t_Character_ProfileID

	ffj_t_Character_Outfit

	ffj_t_Character_OnlineStatus

	ffj_t_Character_Stats

	ffj_t_Character_Faction

	ffj_t_Character_Items

	ffj_t_Character_FriendsList

	ffj_t_Character_World

	ffj_t_Character_Error

	ffj_t_Character_Expires

	ffj_t_Character_LastUpdated
)

var ffj_key_Character_ID = []byte("character_id")

var ffj_key_Character_Name = []byte("name")

var ffj_key_Character_FactionID = []byte("faction_id")

var ffj_key_Character_TitleID = []byte("title_id")

var ffj_key_Character_Times = []byte("times")

var ffj_key_Character_Certs = []byte("certs")

var ffj_key_Character_Battlerank = []byte("battle_rank")

var ffj_key_Character_DailyRibbon = []byte("daily_ribbon")

var ffj_key_Character_ProfileID = []byte("profile_id")

var ffj_key_Character_Outfit = []byte("outfit")

var ffj_key_Character_OnlineStatus = []byte("online_status")

var ffj_key_Character_Stats = []byte("stats")

var ffj_key_Character_Faction = []byte("faction")

var ffj_key_Character_Items = []byte("items")

var ffj_key_Character_FriendsList = []byte("friends_list")

var ffj_key_Character_World = []byte("world_id")

var ffj_key_Character_Error = []byte("error")

var ffj_key_Character_Expires = []byte("expires")

var ffj_key_Character_LastUpdated = []byte("last-updated")

func (uj *Character) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *Character) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_Characterbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_Characterno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'b':

					if bytes.Equal(ffj_key_Character_Battlerank, kn) {
						currentKey = ffj_t_Character_Battlerank
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'c':

					if bytes.Equal(ffj_key_Character_ID, kn) {
						currentKey = ffj_t_Character_ID
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_Character_Certs, kn) {
						currentKey = ffj_t_Character_Certs
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'd':

					if bytes.Equal(ffj_key_Character_DailyRibbon, kn) {
						currentKey = ffj_t_Character_DailyRibbon
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'e':

					if bytes.Equal(ffj_key_Character_Error, kn) {
						currentKey = ffj_t_Character_Error
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_Character_Expires, kn) {
						currentKey = ffj_t_Character_Expires
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'f':

					if bytes.Equal(ffj_key_Character_FactionID, kn) {
						currentKey = ffj_t_Character_FactionID
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_Character_Faction, kn) {
						currentKey = ffj_t_Character_Faction
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_Character_FriendsList, kn) {
						currentKey = ffj_t_Character_FriendsList
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'i':

					if bytes.Equal(ffj_key_Character_Items, kn) {
						currentKey = ffj_t_Character_Items
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'l':

					if bytes.Equal(ffj_key_Character_LastUpdated, kn) {
						currentKey = ffj_t_Character_LastUpdated
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'n':

					if bytes.Equal(ffj_key_Character_Name, kn) {
						currentKey = ffj_t_Character_Name
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'o':

					if bytes.Equal(ffj_key_Character_Outfit, kn) {
						currentKey = ffj_t_Character_Outfit
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_Character_OnlineStatus, kn) {
						currentKey = ffj_t_Character_OnlineStatus
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'p':

					if bytes.Equal(ffj_key_Character_ProfileID, kn) {
						currentKey = ffj_t_Character_ProfileID
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 's':

					if bytes.Equal(ffj_key_Character_Stats, kn) {
						currentKey = ffj_t_Character_Stats
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 't':

					if bytes.Equal(ffj_key_Character_TitleID, kn) {
						currentKey = ffj_t_Character_TitleID
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_Character_Times, kn) {
						currentKey = ffj_t_Character_Times
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'w':

					if bytes.Equal(ffj_key_Character_World, kn) {
						currentKey = ffj_t_Character_World
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffj_key_Character_LastUpdated, kn) {
					currentKey = ffj_t_Character_LastUpdated
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_Character_Expires, kn) {
					currentKey = ffj_t_Character_Expires
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_Character_Error, kn) {
					currentKey = ffj_t_Character_Error
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffj_key_Character_World, kn) {
					currentKey = ffj_t_Character_World
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_Character_FriendsList, kn) {
					currentKey = ffj_t_Character_FriendsList
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_Character_Items, kn) {
					currentKey = ffj_t_Character_Items
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_Character_Faction, kn) {
					currentKey = ffj_t_Character_Faction
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_Character_Stats, kn) {
					currentKey = ffj_t_Character_Stats
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_Character_OnlineStatus, kn) {
					currentKey = ffj_t_Character_OnlineStatus
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_Character_Outfit, kn) {
					currentKey = ffj_t_Character_Outfit
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffj_key_Character_ProfileID, kn) {
					currentKey = ffj_t_Character_ProfileID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffj_key_Character_DailyRibbon, kn) {
					currentKey = ffj_t_Character_DailyRibbon
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_Character_Battlerank, kn) {
					currentKey = ffj_t_Character_Battlerank
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_Character_Certs, kn) {
					currentKey = ffj_t_Character_Certs
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_Character_Times, kn) {
					currentKey = ffj_t_Character_Times
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffj_key_Character_TitleID, kn) {
					currentKey = ffj_t_Character_TitleID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffj_key_Character_FactionID, kn) {
					currentKey = ffj_t_Character_FactionID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_Character_Name, kn) {
					currentKey = ffj_t_Character_Name
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffj_key_Character_ID, kn) {
					currentKey = ffj_t_Character_ID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_Characterno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_Character_ID:
					goto handle_ID

				case ffj_t_Character_Name:
					goto handle_Name

				case ffj_t_Character_FactionID:
					goto handle_FactionID

				case ffj_t_Character_TitleID:
					goto handle_TitleID

				case ffj_t_Character_Times:
					goto handle_Times

				case ffj_t_Character_Certs:
					goto handle_Certs

				case ffj_t_Character_Battlerank:
					goto handle_Battlerank

				case ffj_t_Character_DailyRibbon:
					goto handle_DailyRibbon

				case ffj_t_Character_ProfileID:
					goto handle_ProfileID

				case ffj_t_Character_Outfit:
					goto handle_Outfit

				case ffj_t_Character_OnlineStatus:
					goto handle_OnlineStatus

				case ffj_t_Character_Stats:
					goto handle_Stats

				case ffj_t_Character_Faction:
					goto handle_Faction

				case ffj_t_Character_Items:
					goto handle_Items

				case ffj_t_Character_FriendsList:
					goto handle_FriendsList

				case ffj_t_Character_World:
					goto handle_World

				case ffj_t_Character_Error:
					goto handle_Error

				case ffj_t_Character_Expires:
					goto handle_Expires

				case ffj_t_Character_LastUpdated:
					goto handle_LastUpdated

				case ffj_t_Characterno_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_ID:

	/* handler: uj.ID type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.ID = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Name:

	/* handler: uj.Name type=struct { First string "json:\"first\""; Lower string "json:\"first_lower\"" } kind=struct quoted=false*/

	{
		/* Falling back. type=struct { First string "json:\"first\""; Lower string "json:\"first_lower\"" } kind=struct */
		tbuf, err := fs.CaptureField(tok)
		if err != nil {
			return fs.WrapErr(err)
		}

		err = json.Unmarshal(tbuf, &uj.Name)
		if err != nil {
			return fs.WrapErr(err)
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_FactionID:

	/* handler: uj.FactionID type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.FactionID = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_TitleID:

	/* handler: uj.TitleID type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.TitleID = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Times:

	/* handler: uj.Times type=struct { Creation string "json:\"creation\""; LastSave string "json:\"last_save\""; LastLogin string "json:\"last_login\""; LoginCount string "json:\"login_count\""; MinutesPlayed string "json:\"minutes_played\"" } kind=struct quoted=false*/

	{
		/* Falling back. type=struct { Creation string "json:\"creation\""; LastSave string "json:\"last_save\""; LastLogin string "json:\"last_login\""; LoginCount string "json:\"login_count\""; MinutesPlayed string "json:\"minutes_played\"" } kind=struct */
		tbuf, err := fs.CaptureField(tok)
		if err != nil {
			return fs.WrapErr(err)
		}

		err = json.Unmarshal(tbuf, &uj.Times)
		if err != nil {
			return fs.WrapErr(err)
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Certs:

	/* handler: uj.Certs type=struct { Earned string "json:\"earned_points\""; Gifted string "json:\"gifted_points\""; Spent string "json:\"spent_points\""; Available string "json:\"available_points\""; PercentToNext string "json:\"percent_to_next\"" } kind=struct quoted=false*/

	{
		/* Falling back. type=struct { Earned string "json:\"earned_points\""; Gifted string "json:\"gifted_points\""; Spent string "json:\"spent_points\""; Available string "json:\"available_points\""; PercentToNext string "json:\"percent_to_next\"" } kind=struct */
		tbuf, err := fs.CaptureField(tok)
		if err != nil {
			return fs.WrapErr(err)
		}

		err = json.Unmarshal(tbuf, &uj.Certs)
		if err != nil {
			return fs.WrapErr(err)
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Battlerank:

	/* handler: uj.Battlerank type=struct { Rank string "json:\"value\""; PercentToNext string "json:\"percent_to_next\"" } kind=struct quoted=false*/

	{
		/* Falling back. type=struct { Rank string "json:\"value\""; PercentToNext string "json:\"percent_to_next\"" } kind=struct */
		tbuf, err := fs.CaptureField(tok)
		if err != nil {
			return fs.WrapErr(err)
		}

		err = json.Unmarshal(tbuf, &uj.Battlerank)
		if err != nil {
			return fs.WrapErr(err)
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_DailyRibbon:

	/* handler: uj.DailyRibbon type=struct { Count string "json:\"count\""; Time string "json:\"time\"" } kind=struct quoted=false*/

	{
		/* Falling back. type=struct { Count string "json:\"count\""; Time string "json:\"time\"" } kind=struct */
		tbuf, err := fs.CaptureField(tok)
		if err != nil {
			return fs.WrapErr(err)
		}

		err = json.Unmarshal(tbuf, &uj.DailyRibbon)
		if err != nil {
			return fs.WrapErr(err)
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ProfileID:

	/* handler: uj.ProfileID type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.ProfileID = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Outfit:

	/* handler: uj.Outfit type=struct { ID string "json:\"outfit_id\""; Name string "json:\"name\""; Alias string "json:\"alias\""; LeaderID string "json:\"leader_character_id\""; MemberCount string "json:\"member_count\""; TimeCreated string "json:\"time_created\"" } kind=struct quoted=false*/

	{
		/* Falling back. type=struct { ID string "json:\"outfit_id\""; Name string "json:\"name\""; Alias string "json:\"alias\""; LeaderID string "json:\"leader_character_id\""; MemberCount string "json:\"member_count\""; TimeCreated string "json:\"time_created\"" } kind=struct */
		tbuf, err := fs.CaptureField(tok)
		if err != nil {
			return fs.WrapErr(err)
		}

		err = json.Unmarshal(tbuf, &uj.Outfit)
		if err != nil {
			return fs.WrapErr(err)
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_OnlineStatus:

	/* handler: uj.OnlineStatus type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.OnlineStatus = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Stats:

	/* handler: uj.Stats type=struct { Stat []struct { Name string "json:\"stat_name\""; ProfileID string "json:\"profile_id\""; ValueForever string "json:\"value_forever\""; ValueMonthly string "json:\"value_monthly\""; ValueWeekly string "json:\"value_weekly\""; ValueDaily string "json:\"value_daily\""; ValueOneLifeMax string "json:\"value_one_life_max\""; LastSave string "json:\"last_save\"" } "json:\"stat\""; StatHistory []struct { Name string "json:\"stat_name\""; AllTime string "json:\"all_time\""; OneLifeMax string "json:\"one_life_max\""; Day map[string]string "json:\"day\""; Month map[string]string "json:\"Month\""; Week map[string]string "json:\"Week\"" } "json:\"stat_history\""; WeaponStat []struct { Name string "json:\"weapon_deaths\""; ItemID string "json:\"item_id\""; VehicleID string "json:\"vehicle_id\""; Value string "json:\"value\""; LastSave string "json:\"last_save\"" } "json:\"weapon_stat\"" } kind=struct quoted=false*/

	{
		/* Falling back. type=struct { Stat []struct { Name string "json:\"stat_name\""; ProfileID string "json:\"profile_id\""; ValueForever string "json:\"value_forever\""; ValueMonthly string "json:\"value_monthly\""; ValueWeekly string "json:\"value_weekly\""; ValueDaily string "json:\"value_daily\""; ValueOneLifeMax string "json:\"value_one_life_max\""; LastSave string "json:\"last_save\"" } "json:\"stat\""; StatHistory []struct { Name string "json:\"stat_name\""; AllTime string "json:\"all_time\""; OneLifeMax string "json:\"one_life_max\""; Day map[string]string "json:\"day\""; Month map[string]string "json:\"Month\""; Week map[string]string "json:\"Week\"" } "json:\"stat_history\""; WeaponStat []struct { Name string "json:\"weapon_deaths\""; ItemID string "json:\"item_id\""; VehicleID string "json:\"vehicle_id\""; Value string "json:\"value\""; LastSave string "json:\"last_save\"" } "json:\"weapon_stat\"" } kind=struct */
		tbuf, err := fs.CaptureField(tok)
		if err != nil {
			return fs.WrapErr(err)
		}

		err = json.Unmarshal(tbuf, &uj.Stats)
		if err != nil {
			return fs.WrapErr(err)
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Faction:

	/* handler: uj.Faction type=struct { Name struct { En string "json:\"en\""; De string "json:\"de\""; Es string "json:\"es\""; Fr string "json:\"fr\""; It string "json:\"it\""; Tr string "json:\"tr\"" } "json:\"name\""; ImageSetID string "json:\"image_set_id\""; ImageID string "json:\"image_id\""; ImagePath string "json:\"image_path\""; CodeTag string "json:\"code_tag\""; UserSelectable string "json:\"user_selectable\"" } kind=struct quoted=false*/

	{
		/* Falling back. type=struct { Name struct { En string "json:\"en\""; De string "json:\"de\""; Es string "json:\"es\""; Fr string "json:\"fr\""; It string "json:\"it\""; Tr string "json:\"tr\"" } "json:\"name\""; ImageSetID string "json:\"image_set_id\""; ImageID string "json:\"image_id\""; ImagePath string "json:\"image_path\""; CodeTag string "json:\"code_tag\""; UserSelectable string "json:\"user_selectable\"" } kind=struct */
		tbuf, err := fs.CaptureField(tok)
		if err != nil {
			return fs.WrapErr(err)
		}

		err = json.Unmarshal(tbuf, &uj.Faction)
		if err != nil {
			return fs.WrapErr(err)
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Items:

	/* handler: uj.Items type=[]struct { ID string "json:\"item_id\""; StackCount string "json:\"stack_count\"" } kind=slice quoted=false*/

	{
		/* Falling back. type=[]struct { ID string "json:\"item_id\""; StackCount string "json:\"stack_count\"" } kind=slice */
		tbuf, err := fs.CaptureField(tok)
		if err != nil {
			return fs.WrapErr(err)
		}

		err = json.Unmarshal(tbuf, &uj.Items)
		if err != nil {
			return fs.WrapErr(err)
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_FriendsList:

	/* handler: uj.FriendsList type=[]struct { ID string "json:\"character_id\""; LastLoginTime string "json:\"last_login_time\""; Onlint string "json:\"online\"" } kind=slice quoted=false*/

	{
		/* Falling back. type=[]struct { ID string "json:\"character_id\""; LastLoginTime string "json:\"last_login_time\""; Onlint string "json:\"online\"" } kind=slice */
		tbuf, err := fs.CaptureField(tok)
		if err != nil {
			return fs.WrapErr(err)
		}

		err = json.Unmarshal(tbuf, &uj.FriendsList)
		if err != nil {
			return fs.WrapErr(err)
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_World:

	/* handler: uj.World type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.World = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Error:

	/* handler: uj.Error type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.Error = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Expires:

	/* handler: uj.Expires type=time.Time kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			state = fflib.FFParse_after_value
			goto mainparse
		}

		tbuf, err := fs.CaptureField(tok)
		if err != nil {
			return fs.WrapErr(err)
		}

		err = uj.Expires.UnmarshalJSON(tbuf)
		if err != nil {
			return fs.WrapErr(err)
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_LastUpdated:

	/* handler: uj.LastUpdated type=time.Time kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			state = fflib.FFParse_after_value
			goto mainparse
		}

		tbuf, err := fs.CaptureField(tok)
		if err != nil {
			return fs.WrapErr(err)
		}

		err = uj.LastUpdated.UnmarshalJSON(tbuf)
		if err != nil {
			return fs.WrapErr(err)
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:
	return nil
}

func (mj *Characters) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if mj == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *Characters) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if mj == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{"character_list":`)
	if mj.Characters != nil {
		buf.WriteString(`[`)
		for i, v := range mj.Characters {
			if i != 0 {
				buf.WriteString(`,`)
			}

			{

				err = v.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
		}
		buf.WriteString(`]`)
	} else {
		buf.WriteString(`null`)
	}
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_Charactersbase = iota
	ffj_t_Charactersno_such_key

	ffj_t_Characters_Characters
)

var ffj_key_Characters_Characters = []byte("character_list")

func (uj *Characters) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *Characters) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_Charactersbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_Charactersno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'c':

					if bytes.Equal(ffj_key_Characters_Characters, kn) {
						currentKey = ffj_t_Characters_Characters
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffj_key_Characters_Characters, kn) {
					currentKey = ffj_t_Characters_Characters
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_Charactersno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_Characters_Characters:
					goto handle_Characters

				case ffj_t_Charactersno_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Characters:

	/* handler: uj.Characters type=[]census.Character kind=slice quoted=false*/

	{

		{
			if tok != fflib.FFTok_left_brace && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			uj.Characters = nil
		} else {

			uj.Characters = make([]Character, 0)

			wantVal := true

			for {

				var v Character

				tok = fs.Scan()
				if tok == fflib.FFTok_error {
					goto tokerror
				}
				if tok == fflib.FFTok_right_brace {
					break
				}

				if tok == fflib.FFTok_comma {
					if wantVal == true {
						// TODO(pquerna): this isn't an ideal error message, this handles
						// things like [,,,] as an array value.
						return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
					}
					continue
				} else {
					wantVal = true
				}

				/* handler: v type=census.Character kind=struct quoted=false*/

				{
					if tok == fflib.FFTok_null {

						state = fflib.FFParse_after_value
						goto mainparse
					}

					err = v.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
					if err != nil {
						return err
					}
					state = fflib.FFParse_after_value
				}

				uj.Characters = append(uj.Characters, v)
				wantVal = false
			}
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:
	return nil
}
